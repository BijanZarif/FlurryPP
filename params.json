{"name":"Flurry++","tagline":"A 2D Flux Reconstruction Code in C++","body":"Flurry++\r\n========\r\n\r\nA 2D Flux Reconstruction CFD Code in C++\r\n\r\nWritten by Jacob Crabill\r\n\r\nAerospace Computing Lab, Stanford University\r\n\r\nBackground / Goals of the Project\r\n=================================\r\n\r\nFlurry is not intended to be a high-performance CFD tool, but rather a 'simple' code to learn about high-order methods, as well as being a testbed for new ideas and methods.  The idea is to have a simple, easy to understand codebase which has been designed from the ground up to be easy to modify in the future.  As a developer of [HiFiLES](https://github.com/HiFiLES/HiFiLES-solver), I have great respect for the high-performance aspect of that code, and the thought that went into optimizing its performance for a specific application.  However, I've also learned the hard way that it's rather difficult to make a large, established code do things that it wasn't designed to do.\r\n\r\nHence, Flurry was born.  To start with, my goal is to create a plain 2D Euler and Navier-Stokes solver on quadrilateral and/or triangular elements, mostly as a learning experience.  As more long-term goals, however, I hope to implement various mesh adaptation and deformation methods, p-adaptation, h- and p-multigrid, etc., and as such the code will be structured in such a way to make that possible some day.\r\n\r\nIn the meantime, if you actually took the time to read this, then you should really check out the high-performance GPU-capable Flux Reconstruction code HiFiLES: http://github.com/HiFiLES/HiFiLES-solver.\r\nThis open-source code is under development by the Aerospace Computing Lab at Stanford, with new features in the works all the time in its various branches (it is a research code, after all).\r\n\r\n\r\nCurrent Capabilities\r\n====================\r\n\r\nFlurry is currently capable of running scalar advection or Euler (inviscid Navier-Stokes) cases on unstructured mixed grids of quadrilaterals and triangles in the Gmsh format.  It can either run in serial, pseudo-parallel using OpenMP, or completely parallel using MPI (the code has been tested on up to 24 cores of a computing cluster).  Moving grids are supported by the solver, but there are not yet any grid-motion functions implemented beyond a standard test case.  Shock capturing has also been implemented, and will be pulled into the master branch soon.\r\n\r\n\r\nQuick Start\r\n===========\r\n\r\nCompilation Instructions\r\n-------------------------\r\n\r\nTo compile Flurry, you can either use QT Creator (https://www.qt.io/download-open-source/), which is an excellent C++ IDE that I use for development, or you can use the provided makefile to compile using GNU make.  For the make option, just open a terminal and run the following:\r\n\r\n`make`\r\n\r\nOptionally, you can specify the type of build as either *debug* or *release*:\r\n\r\n`make release`\r\n\r\nwhere *release* turns on full optimization, and *debug* removes all optimization and adds flags for both debugging and profiling.  \r\nThe code also (optionally) utilizes either OpenMP to take advantage of easy parallelization on desktop computers, or MPI to completely parallelize on both shared- and distributed-memory systems.  To enable OpenMP or MPI when compiling, just do one of the following:\r\n\r\n`make openmp`\r\n\r\n`make mpi`\r\n\r\nNote that compiling with MPI requires several external libraries and header files (metis.h/metis.a, mpi.h), the location of which must be specified in the makefile.\r\n\r\n\r\nTest Cases\r\n-------------------------\r\n\r\nSeveral basic test cases have been created to verify the functionality of the code.  The first test case is for the advection equation (in 'tests/advection'), and is simply the advection of a Gaussian bump in a periodic domain.\r\nThe other two test cases are for the inviscid Navier-Stokes (Euler) equations.  \r\nOne is for supersonic flow over a wedge, and the other is for subsonic flow over a circular cylinder.  \r\nNote that the shock capturing capability is still under development, so transonic/supersonic flows should be approached with caution.\r\nThe cylinder test case uses a very coarse mesh, and is intended purely for the purpose of testing the functionality of the code on arbitrary unstructured quad/tri meshes from [Gmsh](geuz.org/gmsh/), and demonstrating the method for applying boundary conditions to Gmsh meshes.\r\n\r\n\r\nPost-Processing\r\n-------------------------\r\n\r\nFlurry currently has two options for viewing simulation data: ParaView .vtu files, and a super-simple .csv file.  In both cases, the output values are the primitive variables, not the conservative variables.  The ParaView files may also be used as 'checkpoints' for restarting a simulation.\r\n\r\nParaView is a free, cross-platform visualization tool that works quite well for visualizing CFD data; you can get it from http://www.paraview.org/.\r\n\r\nThe CSV output method, on the other hand, simply outputs the x,y,z coordinates of the solution points in each element, along with the solution vector at each point. This can be plotted using the provided Matlab script.\r\nIf you write any similar scripts for plotting in other languages (e.g. Python or Julia), please let me know so I can add them here!\r\n\r\n\r\nCode Structure\r\n==============\r\n\r\nFiles\r\n-----\r\n- Flurry\r\n  + Driver\r\n- Input\r\n  + Read input file, set run parameters\r\n- Output\r\n  + Write data to file for restarting, visualization, etc.\r\n- Geometry\r\n  + Read mesh file / generate mesh; setup eles & faces\r\n- Flux\r\n  + Routines to calculate the inviscid & viscous fluxes\r\n- Polynomials\r\n  + Lagrange, Legendre, and other useful polynomials and functions\r\n\r\n\r\nBasic Classes\r\n--------------\r\n- Operators\r\n  + Pre-computes and stores matrices for interpolation, extrapolation, etc. of polynomial bases for all elements in current solution\r\n- Ele\r\n  + Each 'ele' is a single element in the mesh, and stores its solution, Jacobian, shape nodes, and global face IDs of its faces\r\n- Face\r\n  + Either an internal face, boundary face, or MPI face\r\n  + Each face stores the ID of the L/R cells (or the boundary condition) & local face ID of each\r\n  + Calculates interface flux or boundary flux\r\n  + Passes the interface flux difference (common minus discontinuous) back to the L/R elements\r\n  + Boundary conditions are applied weakly; the right state of boundary faces is such that a central flux between the left and right states produces the correct common flux\r\n- Solver\r\n  + Applies the various FR operations to a solution (set of eles, faces, operators, and geometry)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}